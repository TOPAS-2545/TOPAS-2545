package main

import (
    "os"
    "io/ioutil"
    //"bytes"
    //"io"
    //"encoding/asn1"
    "fmt"
    "testapp/ipmtscd"   
    "github.com/markretallack/ber"
)

func check(e error) {
    if e != nil {
        panic(e)
    }
}


func main() {

    tryme := IPMTSCD.IpmstscdLoopTypeDetectorInformation{
                    LoopOccupancyState: true,
                    LoopOccupancyStateDuration: 33,
                    LoopOccupancyPreviousStateDuration: 33,
                    LoopOccupancyRate: 55.8,
                    LoopVolume: 66,
                }
                
    generatedInnerBytes, err := ber.Marshal(tryme)
    
    if err != nil {
        fmt.Println("Failed to unmarshall message: ", err.Error())
    }

    // we need to wrap the choice so it works correcty
    ipmstscdDetInformationChoice := ber.RawValue{0, 2, false, generatedInnerBytes, []byte{}}

    ipmstscdDetInformation := ber.RawValue{Class: ber.ClassContextSpecific , Tag: 2, IsCompound: true, Bytes: ipmstscdDetInformationChoice.Bytes}
    
    expected := IPMTSCD.IPMSTSCD_Data{

        DetectorController_index: 1,
            
        IpmstscdDetData: []struct{
            IpmstscdDetID       int64
            IpmstscdDetType     ber.Enumerated
            IpmstscdDetInformation  ber.RawValue
            Detector_time_location IPMTSCD.GeneralTimeLocationCore "asn1:\"optional\""
        }{
            {        
                IpmstscdDetID: 22,
                IpmstscdDetType: 0,
                IpmstscdDetInformation: ber.RawValue{ber.ClassContextSpecific, 1, true, ipmstscdDetInformation.Bytes, []byte{}},
            },
        },
        
    }

    generatedBytes, err := ber.Marshal(expected)    
    
    
    err = os.WriteFile("det.ber", generatedBytes, 0644)
    check(err)
    
        
    fmt.Println("generation complete")

    // load in the BER generated by the python system

    contents,_ := ioutil.ReadFile("../python-detector.ber")

    var t IPMTSCD.IPMSTSCD_Data

    rest, err := ber.Unmarshal(contents, &t)

    fmt.Println("DetectorController_index: ",t.DetectorController_index)
    
    check(err)
    
    fmt.Println(string(rest))
    
    
    fmt.Println("DetectorController_index: ",t.DetectorController_index)
    
    fmt.Println("IpmstscdDetID: ",t.IpmstscdDetData[0].IpmstscdDetID)
    fmt.Println("IpmstscdDetType: ",t.IpmstscdDetData[0].IpmstscdDetType)
    
    if t.IpmstscdDetData[0].IpmstscdDetType != 0 {
        panic("Not correct Detector type")        
    }
    
    var loopData IPMTSCD.IpmstscdLoopTypeDetectorInformation 
    
    //next, err := ber.Unmarshal(raw.Bytes, &loopData)
    next, err := ber.Unmarshal(t.IpmstscdDetData[0].IpmstscdDetInformation.Bytes, &loopData)
    
    check(err)
    
    fmt.Println(string(next))
    
    fmt.Println("LoopOccupancyState: ",loopData.LoopOccupancyState)
    
}


